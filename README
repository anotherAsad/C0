2021-10-05

- This project contains the falling-edge triggered flip-flops based implementation of C0 core.
- The base project for this was (probably) the "clockBug" commit in the RnD folder of original C0 commit on github.
- The project was reopened in order to review the nature of the clock bug, and precisely validate the theorized causes
  via simulation.
- Refresher: There are only two main sequential block components in the entire design:
	1) The Register Bank.
	2) The Instruction Pointer.
- Refresher: When the clockBug was first identified, it is believed that the Register Bank was falling edge triggered,
  while the Instruction Pointer was rising edge triggered (by inverting clock to the input of IPTR). Probably, because
  I believed that the Instruction, and consequently the IPTR must be sheld stable around the falling edge of clock to
  properly execute the instruction. But this introduced a class of bugs that I like to call "FALSE CLOCK EDGE" bugs.
- FALSE CLOCK EDGE bugs occur due to faulty clock gating, whereby the enable signal of clock-gate causes clock edge
  generation just after clock-edge transition. The professional way of avoiding it is to avoid clock gating as 
  flip-flop enable mechanism.
- In the particular case of posedge IPTR and negedge Register Bank, the rising edge updates IPTR, and consequently,
  the instruction on the core's input. At the Register Bank's clock-gating AND-gate instance, the rising edge of clock,
  when followed by a falling enable (i.e. an instruction with enable HI followed by and instruction with enable LO),
  causes a FALSE FALLING CLOCK EDGE. The width of pulse that terminates with falling edge is equals:
  the time delay of rising clock edge - the time delay of instruction change.
  ^^ this time difference is the duration for which the clock-gate is active.
- A single change in this reopening, i.e. making both IPTR and Register bank falling-edge triggered, fixed the bug.
  When both sequential blocks are falling-edge triggered, the falling edge of clock on the clock-gate of Regbank
  closes the gate, hence making its output immune to any subsequent changes of enable bit of clock-gate due to changing
  instruction.
- Moreover, to make this bad flip-flop design better, the clock gate is shifted from BEFORE the Regbank Decoder (DEC)
  to AFTER the Regbank Decoder. This eliminates the metastable transition of decoder outputs (like changing Register
  select line from 0 to 3, may change R0E, R1E, R2E and R3E bits in their metastable state, which in turn issues
  falling edges to enables of R0, R1, R2 or R3 if CLK is also HI).